# Episode 254: Ecto 2.0

A couple of weeks ago, Ecto 2.0 was released.  Today we'll look at it from the
ground up, rather than have a strict discussion of what's changed.  I've linked
to the CHANGELOG in the resources section.  Let's get started.

## Project

### Setup (Off-Video)

We'll kick off a new project:

```sh
mix new ecto_playground --sup
cd ecto_playground
vim mix.exs
```

```elixir
defmodule EctoPlayground.Mixfile do
  use Mix.Project

  def project do
    [app: :ecto_playground,
     version: "0.1.0",
     elixir: "~> 1.4-dev",
     build_embedded: Mix.env == :prod,
     start_permanent: Mix.env == :prod,
     deps: deps()]
  end

  def application do
    [applications: [:postgrex, :ecto, :logger],
     mod: {EctoPlayground, []}]
  end

  defp deps do
    [
      {:postgrex, "~> 0.11.2"},
      {:ecto, "~> 2.0"}
    ]
  end
end
```

```sh
mix deps.get
```

### Playtime

We've got a basic project setup with ecto and postgrex as dependencies.  We want
to start off by adding a Repo, which is our wrapper around the database:

```sh
mkdir lib/ecto_playground
vim lib/ecto_playground/repo.ex
```

```elixir
defmodule EctoPlayground.Repo do
  use Ecto.Repo, otp_app: :ecto_playground
end
```

Here we've defined a repo, telling it to look for its configuration in the
`:ecto_playground` OTP app.  Now we'll configure it.

```sh
vim config/config.exs
```

```elixir
use Mix.Config

# We have to specify our list of repos in configuration
config :ecto_playground, ecto_repos: [EctoPlayground.Repo]

# And we'll configure our repo.  My user has superuser access on postgres, so I
# don't need to provide a username or password.
config :ecto_playground, EctoPlayground.Repo,
  adapter: Ecto.Adapters.Postgres,
  database: "ecto_playground"
```

I'll create the database:

```sh
mix ecto.create
```

Now we can start to make some data with schemas.  Before 2.0, Ecto referred to
things as `Model`s, but now Ecto just has data, which makes a lot of sense -
this is not Object Oriented Programming, and Ecto is not an Object-Relational
Mapper.

We'll start to build something like the model for DailyDrip.  First, we want to
define some topics:

```elixir
defmodule EctoPlayground.Topic do
  use Ecto.Schema

  schema "topics" do
    field :title, :string
    field :description, :string
    field :slug, :string

    timestamps()
  end
end
```

We'll write a test now to create topics.  For what it's worth, you probably want
to define multiple databases for different environments, but for this
demonstration it's not so important.

```elixir
defmodule EctoPlaygroundTest do
  use ExUnit.Case
  alias EctoPlayground.Repo
  alias EctoPlayground.Topic

  test "creating topics" do
    topic =
      %Topic{
        title: "Elixir",
        description: "Awesome fault-tolerant concurrency-oriented language",
        slug: "elixir"
      }
    {:ok, inserted_topic} = Repo.insert(topic)
    assert inserted_topic.id
  end
end
```

We can run the test...and it fails.  This is because our Repo isn't running.  We
need to add it to our supervision tree:

```elixir
defmodule EctoPlayground do
  use Application

  def start(_type, _args) do
    import Supervisor.Spec, warn: false

    children = [
      supervisor(EctoPlayground.Repo, [])
    ]

    opts = [strategy: :one_for_one, name: EctoPlayground.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

Now if we run the tests, they'll fail because we haven't run our migrations.
Let's make our test suite drop the database and migrate at the beginning of each
run.  I used to do this in the `test_helper.exs`, but now the appropriate thing
is to modify your test alias to do it:

```elixir
defmodule EctoPlayground.Mixfile do
  def project do
    [
      #...
      aliases: aliases(),
      #...
    ]
  end
  # ...
  defp aliases do
    [
      "test": ["ecto.drop --quiet", "ecto.create --quiet", "ecto.migrate", "test"]
    ]
  end
end
```

Now we can run our tests:

```sh
mix test
```

And they point out we have no migrations, woops.  Let's add one for our `topics`
table:

```sh
mix ecto.gen.migration create_topics
```

```elixir
defmodule EctoPlayground.Repo.Migrations.CreateTopics do
  use Ecto.Migration

  def change do
    create table(:topics) do
      add :title, :string
      add :description, :text
      add :slug, :text

      timestamps()
    end
  end
end
```

Now we can run the tests:

```sh
mix test
```

And they pass.  So that's a basic Ecto setup in place.  Let's add another table
and look at references:

```sh
mix ecto.gen.migration create_drips
```

```elixir
defmodule EctoPlayground.Repo.Migrations.CreateDrips do
  use Ecto.Migration

  def change do
    create table(:drips) do
      add :identifier, :string
      add :title, :string
      add :teaser, :string
      add :slug, :string
      add :description, :text
      add :video, :string
      add :video_length, :integer
      add :topic_id, references(:topics)

      timestamps()
    end
  end
end
```

OK, so we reference the topic there.  We can build out the schema so this table
is useful:

```sh
vim lib/ecto_playground/drip.ex
```

```elixir
defmodule EctoPlayground.Drip do
  use Ecto.Schema

  schema "drips" do
    field :identifier, :string
    field :title, :string
    field :teaser, :string
    field :slug, :string
    field :description, :string
    field :video, :string
    field :video_length, :integer
    belongs_to :topic, EctoPlayground.Topic

    timestamps()
  end
end
```

And we want the topic to know about its drips:

```elixir
defmodule EctoPlayground.Topic do
  use Ecto.Schema

  schema "topics" do
    field :title, :string
    field :description, :string
    field :slug, :string
    has_many :drips, EctoPlayground.Drip

    timestamps
  end
end
```

So now we can write another test verifying that we can create drips under this
topic:

```elixir
defmodule EctoPlayground.DripTest do
  use ExUnit.Case, async: true

  alias EctoPlayground.Repo
  alias EctoPlayground.Topic
  alias EctoPlayground.Drip

  describe "for a given topic" do
    setup [:create_topic]

    test "we can create a drip", %{elixir: elixir} do
      drip =
        %Drip{
          identifier: "001.1",
          title: "Introducing Elixir",
          teaser: "Why should you even care about Elixir?",
          slug: "introducing-elixir",
          description: "Some text goes here",
          video: "http://www.elixir-lang.org",
          video_length: 100,
          topic: elixir
        }
        {:ok, inserted_drip} = Repo.insert(drip)
        assert inserted_drip.topic.slug == "elixir"
        assert inserted_drip.id
    end
  end

  defp create_topic(context) do
    elixir =
      %Topic{
        title: "Elixir",
        description: "Awesome fault-tolerant concurrency-oriented language",
        slug: "elixir"
      }
    {:ok, inserted_topic} = Repo.insert(elixir)
    {:ok, elixir: inserted_topic}
  end
end
```

This is using the new ExUnit `describe` blocks and named setup, which seem very
cool, although honestly I'm not 100% clear on how the results of the setup
functions get merged in the event of multiples.  I would assume collisions just
override, but it's interesting to me at any rate.

## Summary

So this was a basic introduction to Ecto 2.0.  Not supremely different from the
1.x series, but different enough.  We'll look at some more features it provides
in future episodes.  See you soon!

## Resources

- [Ecto docs](https://hexdocs.pm/ecto/Ecto.html)
- [Ecto 2.0 CHANGELOG](https://github.com/elixir-ecto/ecto/blob/master/CHANGELOG.md#changelog-for-v20)
- [GH Issue talking about proper way to handle test database migrations](https://github.com/elixir-ecto/ecto/issues/1288)
